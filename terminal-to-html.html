<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Terminal to HTML</title>
  <style>
    :root {
      /* Light mode variables */
      --background-color: #fffcf1;
      --text-color: #000000;
      --border-color: #ddd;
      --button-color: #000000;
      --button-text: #fffcf1;
      --container-bg: #f5f2e6;
      --textarea-bg: #f5f2e6;
    }

    @media (prefers-color-scheme: dark) {
      :root {
        /* Dark mode variables */
        --background-color: #181a1b;
        --text-color: #fffcf1;
        --border-color: #3a3e40;
        --button-color: #000000;
        --button-text: #fffcf1;
        --container-bg: #2b2a32;
        --textarea-bg: #2b2a32;
      }
    }

    * {
      margin: 0;
      padding: 0;
      box-sizing: border-box;
    }

    body {
      font-family: Arial, sans-serif;
      background: var(--background-color);
      color: var(--text-color);
      line-height: 1.6;
    }

    .container {
      max-width: 1400px;
      margin: 0 auto;
      padding: 2rem;
    }

    header {
      margin-bottom: 2rem;
    }

    .instructions {
      background: var(--container-bg);
      border-left: 4px solid var(--border-color);
      padding: 15px;
      margin-bottom: 20px;
      border-radius: 4px;
    }

    .paste-area {
      width: 100%;
      min-height: 120px;
      padding: 15px;
      border: 2px dashed var(--border-color);
      border-radius: 8px;
      background: var(--textarea-bg);
      color: var(--text-color);
      font-family: 'Courier New', Courier, monospace;
      font-size: 16px;
      margin-bottom: 20px;
      outline: none;
      transition: border-color 0.3s;
      resize: vertical;
    }

    .paste-area:focus {
      border-color: var(--text-color);
      border-style: solid;
    }

    .paste-area::placeholder {
      color: var(--text-color);
      opacity: 0.6;
    }

    .results {
      display: flex;
      flex-direction: column;
      gap: 20px;
    }

    .section {
      background: var(--container-bg);
      border-radius: 8px;
      border: 1px solid var(--border-color);
      padding: 20px;
    }

    .section h2 {
      margin-top: 0;
      color: var(--text-color);
      font-size: 18px;
      border-bottom: 1px solid var(--border-color);
      padding-bottom: 10px;
      margin-bottom: 15px;
    }

    .code-output {
      width: 100%;
      min-height: 200px;
      padding: 15px;
      border: 1px solid var(--border-color);
      border-radius: 4px;
      background: var(--background-color);
      color: var(--text-color);
      font-family: 'Courier New', Courier, monospace;
      font-size: 14px;
      resize: vertical;
      overflow-x: auto;
      white-space: pre;
    }

    .button-group {
      display: flex;
      gap: 10px;
      margin-bottom: 15px;
      flex-wrap: wrap;
    }

    button {
      padding: 8px 16px;
      background: var(--button-color);
      color: var(--button-text);
      border: none;
      border-radius: 4px;
      cursor: pointer;
      font-size: 14px;
      font-family: Arial, sans-serif;
      transition: opacity 0.2s;
    }

    button:hover {
      opacity: 0.8;
    }

    button:disabled {
      opacity: 0.7;
      cursor: not-allowed;
    }

    button.copied {
      background: var(--button-color);
      opacity: 0.6;
    }

    .preview-container {
      background: var(--background-color);
      border: 1px solid var(--border-color);
      border-radius: 4px;
      padding: 0;
      overflow-x: auto;
      max-width: 100%;
    }

    .preview-container pre {
      margin: 0;
      padding: 15px;
      white-space: pre;
      overflow-x: visible;
      width: max-content;
      min-width: 100%;
    }

    .empty-state {
      text-align: center;
      color: var(--text-color);
      opacity: 0.7;
      padding: 40px;
      font-size: 18px;
      font-style: italic;
    }

    .error {
      background: var(--container-bg);
      border-left: 4px solid #f00;
      padding: 15px;
      margin-bottom: 20px;
      border-radius: 4px;
      color: #f00;
    }

    .gist-links {
      margin-top: 15px;
      padding: 15px;
      background: var(--background-color);
      border: 1px solid var(--border-color);
      border-radius: 4px;
    }

    .gist-links a {
      color: var(--text-color);
      text-decoration: underline;
      display: inline-block;
      margin-right: 10px;
      padding: 5px;
    }

    .gist-links a:hover {
      opacity: 0.8;
    }


    @media (max-width: 768px) {
      .container {
        padding: 1rem;
      }

      h1 {
        font-size: 24px;
      }

      .button-group {
        flex-direction: column;
      }

      button {
        width: 100%;
      }
    }
  </style>
</head>
<body>
  <div class="container">
    <header>
      <h1>Terminal to HTML</h1>
      <p id="description">
        A simple tool to convert terminal output to HTML - supports RTF (colored terminal output), HTML, or plain text.
      </p>
      <p><small>Fully inspired by and adapted from <a href="https://tools.simonwillison.net/terminal-to-html" style="color: var(--text-color);">Simon Willison's Terminal to HTML tool</a>.</small></p>
    </header>

    <div class="instructions">
      <strong>Instructions:</strong> Paste terminal output below. Supports RTF (colored terminal output), HTML, or plain text.
    </div>

    <textarea class="paste-area" placeholder="Click here and paste your terminal output (Cmd+V or Ctrl+V)..."></textarea>

    <div class="results" id="results">
      <div class="empty-state">Paste terminal output to see the HTML conversion</div>
    </div>
  </div>

<script type="module">
const pasteArea = document.querySelector('.paste-area');
const resultsDiv = document.getElementById('results');

function parseRTFColor(colorDef) {
  const redMatch = colorDef.match(/\\red(\d+)/);
  const greenMatch = colorDef.match(/\\green(\d+)/);
  const blueMatch = colorDef.match(/\\blue(\d+)/);

  if (redMatch && greenMatch && blueMatch) {
    const r = parseInt(redMatch[1]);
    const g = parseInt(greenMatch[1]);
    const b = parseInt(blueMatch[1]);
    return `rgb(${r}, ${g}, ${b})`;
  }
  return null;
}

function parseRTFColorTable(rtf) {
  const colorTableMatch = rtf.match(/\{\\colortbl;([^}]+)\}/);
  if (!colorTableMatch) return [];

  const colorTable = [null];
  const colorDefs = colorTableMatch[1].split(';');

  for (const colorDef of colorDefs) {
    if (colorDef.trim()) {
      const color = parseRTFColor(colorDef.trim());
      colorTable.push(color);
    }
  }

  return colorTable;
}

function rtfToHtml(rtf) {
  const colorTable = parseRTFColorTable(rtf);

  let backgroundColor = null;
  let defaultTextColor = null;

  const initialFormatMatch = rtf.match(/\\f0\\fs\d+\s+\\cf(\d+)\s+\\cb(\d+)/);
  if (initialFormatMatch) {
    const textColorIndex = parseInt(initialFormatMatch[1]);
    const bgColorIndex = parseInt(initialFormatMatch[2]);
    defaultTextColor = colorTable[textColorIndex];
    backgroundColor = colorTable[bgColorIndex];
  }

  const pardIndex = rtf.indexOf('\\pard');
  if (pardIndex === -1) {
    throw new Error('Could not find paragraph content');
  }

  const contentPattern = /\\f0\\fs\d+\s+\\cf\d+\s+\\cb\d+\s+\\CocoaLigature\d+\s+/;
  const match = rtf.substring(pardIndex).match(contentPattern);

  if (!match) {
    throw new Error('Could not find content start marker');
  }

  const contentStartOffset = pardIndex + match.index + match[0].length;
  const lastBrace = rtf.lastIndexOf('}');
  let content = rtf.substring(contentStartOffset, lastBrace);

  let html = '';
  let i = 0;
  let currentColor = defaultTextColor;
  let currentBgColor = backgroundColor;
  let isBold = false;

  while (i < content.length) {
    const char = content[i];

    if (char === '\\') {
      let controlWord = '';
      let j = i + 1;

      if (j < content.length && content[j] === "'") {
        j++;
        let hexCode = '';
        while (j < content.length && /[0-9a-fA-F]/.test(content[j]) && hexCode.length < 2) {
          hexCode += content[j];
          j++;
        }
        if (hexCode.length === 2) {
          const charCode = parseInt(hexCode, 16);
          html += String.fromCharCode(charCode);
          i = j;
          continue;
        }
      }

      while (j < content.length && /[a-z]/i.test(content[j])) {
        controlWord += content[j];
        j++;
      }

      let numParam = '';
      while (j < content.length && /[0-9]/.test(content[j])) {
        numParam += content[j];
        j++;
      }

      if (j < content.length && content[j] === ' ') {
        j++;
      }

      if (controlWord === 'cf') {
        const colorIndex = parseInt(numParam);
        currentColor = colorTable[colorIndex] || defaultTextColor;
        i = j;
      } else if (controlWord === 'cb') {
        const colorIndex = parseInt(numParam);
        currentBgColor = colorTable[colorIndex] || backgroundColor;
        i = j;
      } else if (controlWord === 'b') {
        if (numParam === '0') {
          isBold = false;
        } else {
          isBold = true;
        }
        i = j;
      } else if (controlWord === 'uc') {
        i = j;
      } else if (controlWord === 'u') {
        const codePoint = parseInt(numParam);
        if (codePoint < 0) {
          const unsigned = 65536 + codePoint;
          html += String.fromCharCode(unsigned);
        } else {
          html += String.fromCharCode(codePoint);
        }
        if (j < content.length && content[j] === '?') {
          j++;
        }
        i = j;
      } else if (controlWord === '') {
        if (i + 1 < content.length) {
          const nextChar = content[i + 1];
          if (nextChar === '\\') {
            html += '\\';
            i += 2;
          } else if (nextChar === '\n') {
            html += '\n';
            i += 2;
          } else {
            i++;
          }
        } else {
          i++;
        }
      } else {
        i = j;
      }
    } else if (char === '\n') {
      html += '\n';
      i++;
    } else {
      let text = '';

      while (i < content.length && content[i] !== '\\' && content[i] !== '\n') {
        text += content[i];
        i++;
      }

      if (text.length > 0) {
        const styles = [];
        if (currentColor) {
          styles.push(`color: ${currentColor}`);
        }
        if (currentBgColor && currentBgColor !== backgroundColor) {
          styles.push(`background: ${currentBgColor}`);
        }
        if (isBold) {
          styles.push('font-weight: bold');
        }

        if (styles.length > 0) {
          html += `<span style="${styles.join('; ')};">${escapeHtml(text)}</span>`;
        } else {
          html += escapeHtml(text);
        }
      }
    }
  }

  return { html, backgroundColor, defaultTextColor };
}

function escapeHtml(text) {
  const div = document.createElement('div');
  div.textContent = text;
  return div.innerHTML;
}

function wrapInHtmlDocument(content, backgroundColor = 'black', defaultTextColor = '#00ff00') {
  return `<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Terminal Output</title>
</head>
<body style="background: ${backgroundColor}; color: ${defaultTextColor}; margin: 0; padding: 0; font-family: monospace;">
${content}
</body>
</html>`;
}

async function createGist(htmlContent) {
  const createGistBtn = document.getElementById('createGistBtn');
  const gistLinks = document.getElementById('gistLinks');

  try {
    // Copy HTML content to clipboard
    await navigator.clipboard.writeText(htmlContent);

    // Open GitHub's new gist page
    window.open('https://gist.github.com/', '_blank');

    // Show success message
    gistLinks.style.display = 'block';
    gistLinks.innerHTML = `
      <div style="color: var(--text-color); margin-bottom: 10px;">
        âœ“ HTML content copied to clipboard!<br>
        A new tab with GitHub Gist has been opened - just paste the content there.<br><br>
        <strong>Tip:</strong> After creating your gist, you can view the rendered HTML at:<br>
        <code style="background: var(--container-bg); padding: 2px 4px; border-radius: 2px; font-family: monospace;">https://gistpreview.github.io/?YOUR_GIST_ID</code>
      </div>
    `;

    // Update button temporarily
    createGistBtn.textContent = 'Content Copied!';
    createGistBtn.classList.add('copied');
    setTimeout(() => {
      createGistBtn.textContent = 'Copy & Create Gist';
      createGistBtn.classList.remove('copied');
    }, 3000);

  } catch (err) {
    console.error('Failed to copy content:', err);
    gistLinks.style.display = 'block';
    gistLinks.innerHTML = '<div style="color: #f00;">Failed to copy content to clipboard.</div>';
  }
}

pasteArea.addEventListener('paste', async (e) => {
  e.preventDefault();

  const clipboardData = e.clipboardData;
  resultsDiv.innerHTML = '';

  if (!clipboardData) {
    resultsDiv.innerHTML = '<div class="empty-state">No clipboard data detected</div>';
    return;
  }

  let htmlOutput = '';
  let fullHtml = '';

  const htmlData = clipboardData.getData('text/html');

  if (htmlData) {
    htmlOutput = htmlData;
    fullHtml = wrapInHtmlDocument(htmlData, 'black', '#ffffff');
  } else {
    const rtfData = clipboardData.getData('text/rtf');

    if (rtfData) {
      try {
        const result = rtfToHtml(rtfData);
        htmlOutput = result.html;
        const backgroundColor = result.backgroundColor || 'black';
        const defaultTextColor = result.defaultTextColor || '#ffffff';

        let preStyle = '';
        const styles = [];
        if (backgroundColor) {
          styles.push(`background: ${backgroundColor}`);
        }
        if (defaultTextColor) {
          styles.push(`color: ${defaultTextColor}`);
        }
        if (styles.length > 0) {
          preStyle = ` style="${styles.join('; ')}; padding: 15px; border-radius: 4px;"`;
        }
        fullHtml = wrapInHtmlDocument(`<pre${preStyle}>${htmlOutput}</pre>`, backgroundColor, defaultTextColor);
      } catch (error) {
        resultsDiv.innerHTML = `<div class="error">Error parsing RTF: ${error.message}</div>`;
        return;
      }
    } else {
      const plainText = clipboardData.getData('text/plain');

      if (plainText) {
        htmlOutput = escapeHtml(plainText);
        fullHtml = wrapInHtmlDocument(`<pre style="color: #ffffff; padding: 15px;">${htmlOutput}</pre>`, 'black', '#ffffff');
      } else {
        resultsDiv.innerHTML = '<div class="error">No supported format detected in clipboard.</div>';
        return;
      }
    }
  }

  const codeSection = document.createElement('div');
  codeSection.className = 'section';
  codeSection.innerHTML = `
    <h2>HTML Code</h2>
    <div class="button-group">
      <button id="copyHtmlBtn">Copy HTML</button>
      <button id="createGistBtn">Copy & Create Gist</button>
    </div>
    <textarea class="code-output" id="htmlOutput" readonly>${escapeHtml(fullHtml)}</textarea>
    <div id="gistLinks" class="gist-links" style="display: none;"></div>
  `;
  resultsDiv.appendChild(codeSection);

  const copyHtmlBtn = document.getElementById('copyHtmlBtn');
  const htmlOutputTextarea = document.getElementById('htmlOutput');
  const createGistBtn = document.getElementById('createGistBtn');

  copyHtmlBtn.addEventListener('click', async () => {
    try {
      await navigator.clipboard.writeText(htmlOutputTextarea.value);
      copyHtmlBtn.textContent = 'Copied!';
      copyHtmlBtn.classList.add('copied');
      setTimeout(() => {
        copyHtmlBtn.textContent = 'Copy HTML';
        copyHtmlBtn.classList.remove('copied');
      }, 2000);
    } catch (err) {
      console.error('Failed to copy HTML:', err);
    }
  });

  createGistBtn.addEventListener('click', () => {
    createGist(fullHtml);
  });

  const previewSection = document.createElement('div');
  previewSection.className = 'section';
  previewSection.innerHTML = `
    <h2>Preview</h2>
    <div class="preview-container">
      ${fullHtml}
    </div>
  `;
  resultsDiv.appendChild(previewSection);
});

pasteArea.addEventListener('paste', () => {
  setTimeout(() => {
    pasteArea.value = '';
  }, 0);
});
</script>
</body>
</html>
